[[runtime]]

== 배치 런타임
---
::

[[runtime-install]]


=== 배치 런타임 설치

:: 배치를 실행하기 위한 런타임 설치는 런타임 배포 패키지(Distribution Package)를 설치 디렉토리 하위에 풀어서 복사한다.

설치 디렉토리 하위에 구성되는 하위 디렉토리 구조는 다음과 같다.

.배치 런타임 디렉토리 구조 
[options="header"]
|===============
^|설치 디렉토리 ^|디렉토리 ^|내용 
.4+.^|[RUNTIME_HOME] |dist/bin |배치 실행을 위한 Shell 명령어 
|dist/lib |라이브러리 
|target |배치 작업 배포 및 설정, Spring Context 위치 (CFG, SQL, Task, VO, propeties, *.xml 등) 

|===============


[[runtime-install-bin]]


==== 명령어 설정(bin)

:: bin 폴더에는 배치 실행을 위한 명령어가 구성되어 있다.


[NOTE]
====

		명령어는 윈도우(.cmd)와 유닉스(.sh) 용 두가지 구성이 있으며 OS에 맞는 명령어 구성을 사용한다.


	
====


.배치 실행 명령어
[options="header"]
|===============
^|구분 ^|명령어 ^|내용 
.6+^.^|UNIX |setenv.sh |환경 구성을 위한 공통 명령어 
|runjob.sh |배치 실행 명령어 
|killjob.sh |배치 강제중지 명령어 
|rundaemon.sh |데몬 실행 명령어 
|stopdaemon.sh |데몬 중지 명령어 
|killdaemon.sh |데몬 강제중지 명령어 
.6+^.^|WINDOW |setenv.cmd |환경 구성을 위한 공통 명령어 
|runjob.cmd |배치 실행 명령어 
|killjob.cmd |배치 강제중지 명령어 
|rundaemon.cmd |데몬 실행 명령어 
|stopdaemon.cmd |데몬 중지 명령어 
|killdaemon.cmd |데몬 강제중지 명령어 

|===============


OS 환경 및 런타임 설치 위치에 따라

++setenv++의 다음 항목을 설정한다.



* JAVA_HOME - Java 설치 위치를 지정한다.

* RUNTIME_HOME - 런타임 설치 위치를 지정한다 .

* VM_MAX_SIZE - 배치 실행 시 적용된 Heap Size를 지정한다. (단위 MB)

.setenv.sh
====

----



#! /bin/sh

export JAVA_HOME="/usr/java/jdk1.6
export RUNTIME_HOME=/DATA/batch/App

CLASSPATH=$RUNTIME_HOME/build:$RUNTIME_HOME/config:

for i in $RUNTIME_HOME/lib/*.jar
do
   CLASSPATH=$CLASSPATH:$i
done

VM_MAX_SIZE=512
... ...
... ...

----


====

[[runtime-install-config]]


==== 런타임 설정(config)

:: config 폴더에는 배치 실행 시 사용되는 설정파일(properties) 및 런타임 구성을 위한 Spring 설정(context)이 포함되어 있다.

.런타임 설정
[options="header"]
|===============
^|구분 ^|항목 ^|내용 
.4+^.^|properties |batch.properties |배치 구동을 위한 각종 속성값을 정의 
|jdbc.properties |DB 접속정보를 정의 
|parameter.properties |배치 환경변수를 정의 
|logback.xml |배치 로깅정책을 정의 
.7+^.^|spring |context-batch-runtime.xml |배치 프레임워크 동작에 필요한 Bean 설정 
|context-batch-transaction.xml |배치 프레임워크에서 접근하는 데이터소스 설정 
|context-daemon-runtime.xml |데몬 실행을 위한 Bean 설정 
|context-batch-meta.xml |배치 작업과 배치 관리도구(Admin) 연계를 위한 Bean 설정 
|daemon-file.xml |파일 데몬 Bean 설정 
|daemon-timer.xml |타이머 데몬 Bean 설정 
|daemon-schedule.xml |스케쥴 데몬 Bean 설정 

|===============


[[runtime-install-config-batch]]


===== batch.properties

:: batch.properties 파일에는 배치 실행 시 필요한 설정 정보와 job, step, reader, writer 생성 시 적용될 기본 속성값 들을 정의하고 있다. (context-batch-runtime.xml의 Bean 속성으로 사용됨 [LINK])

런타임 설치 후 필수적으로 설정되어야 하는 항목은 다음과 같다.

* batch.log.directory - 작업 실행 시 생성되는 로그가 저장될 위치 (Base Directory)

* batch.database.persist - 배치 실행이력을 DB에 저장할지 여부 (로컬 개발 설정은 false, 서버는 true로 설정)

* batch.database.type - 데이터베이스 제품명 ("Apache Derby", "DB2", "DB2ZOS", "HSQL Database Engine", "Microsoft SQL Server", "MySQL", "Oracle", "PostgreSQL", "Sybase", "H2")

.batch.properties
====

----



#############################################
# configurations for batch runtime
#############################################

# absolute base directory where log file is written to
batch.log.directory=/batch/log

# batch runtime context location
batch.context.location=classpath:spring/context-*.xml

# enable/disable to persist execution history to database 
batch.database.persist=true

# type of database
batch.database.type=ORACLE

#############################################
# configurations for batch job
#############################################

# default restartable of job. <job restartable="true/false">
batch.job.restartable=false

# suffix of job configuration file
batch.job.config.suffix=_cfg

# suffix of sql configuration file
batch.sql.config.suffix=_sql

# allow use of setQuery() in program via item reader, writer
batch.sql.allow.custom=false

#############################################
# configurations for batch step
#############################################

# default restartble of step. <step restartable="true/false">
batch.step.restartable=false

# the number of max threads in parallel step (must greater than 1)
batch.step.parallel.max=100

# shell commands allowed to execute
batch.shell.command=copy, move, touch

#############################################
# configurations for reader/writer
#############################################

# encoding/decoding error handling (report:throw exception, replace:replaced with space, ignore:ignore)
batch.charset.overflow=error
batch.charset.malformed=error
batch.charset.unmappable=replace

# buffer size for file reader/writer (default:64Kb) 
batch.file.buffersize=65536

# default file encoding
batch.file.encoding=euc-kr

# escape special char sequence (default:false) 
# ex) delimiter(,) line separator(\r\n) escaping char(")
batch.vsam.escape=false

# when read / write, allow to read null data or not 
# - allow: read/write null data
#- replace: replace null data with default field value (@NotNull @DefaultValue)
#- system: replace null data with system default value (FieldMeta.properties)
#- error: throw exception
batch.item.null=allow

#allow to create item reader/writer in program
batch.item.create=true

#############################################
# configurations for reader
#############################################

# each input bytes must equal vo length (default:true)
batch.reader.sam.fixed=true

# trim white space in string while SAM file reading
batch.reader.sam.trim=true

# trim white space in string while VSAM file reading
batch.reader.vsam.trim=true

# trim white space in string while DB reading
batch.reader.db.trim=false


#############################################
# configurations for writer
#############################################

# delete empty output file when closing (default:false)
batch.writer.file.delete.empty=true

# delete writing files on error. if batch.job.restart=true, this is must be false
batch.writer.file.delete.error=false

# delete writing files on stop. if batch.job.restart=true, this is must be false
batch.writer.file.delete.stop=false

# maximum file size(byte) which is allowed to be wrote (-1: unlimited)
batch.writer.file.max=-1

# overwrite output file existing. if false and output file exists, exception throw
batch.writer.file.overwrite=true

# use temp file when writing files
batch.writer.file.temp=true

# temp file suffix when use temp file 
batch.writer.file.temp.suffix=._BATCH_TMP_



----


====

[[runtime-install-config-jdbc]]


===== jdbc.properties

:: 배치에서 사용할 데이터베이스 접속정보를 지정한다. (context-batch-transaction.xml의 Datasource 속성으로 사용됨 [LINK])

JDBC 드라이버, URL 및 계정정보를 환경에 맞게 설정해야 한다.


[NOTE]
====

		biz_*는 업무에서 사용할 Datasource 설정이며 frw_*는 프레임워크 내부에서 사용하는 Datasource 설정이다.


	
====


.jdbc.properties
====

----



frw_jdbc.driverClassName=oracle.jdbc.OracleDriver
frw_jdbc.url=jdbc:oracle:thin:@127.0.0.0:12511:FRW
frw_jdbc.username=batch
frw_jdbc.password=batch

biz_jdbc.driverClassName=oracle.jdbc.OracleDriver
biz_jdbc.url=jdbc:oracle:thin:@127.0.0.0:12511:FRW
biz_jdbc.username=batch
biz_jdbc.password=batch


----


====

[[runtime-install-config-log]]


===== logback.xml

:: 배치 로그를 설정한다. 로그 파일은

<<runtime-install-config-batch>>의

++batch.log.directory++로 지정된 디렉토리 하위에 생성되며 작업정의(CFG)의 패키지 Path와 동일한 하위 폴더에 생성된다.



운영단계에 따른 로그레벨을 설정한다. (DEBUG, INFO, ERROR)



[source, xml]
----

<turboFilter class="com.anyframe.batch.log.MDCThresholdTurboFilter">
<DefaultLevel>DEBUG</DefaultLevel>
</turboFilter>

----

로그파일의 최대 사이즈를 지정한다. (jobAppender 하위는 작업 로그파일의 크기, stepAppender 하위는 스텝 로그파일의 크기)


[source, xml]
----

<triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">
<maxFileSize>5MB</maxFileSize>
</triggeringPolicy>

----


[NOTE]
====

		배치 프레임워크에서는 로그 출력을 위하여 SLF4J, Logback 로그 프레임워크를 사용한다.


		로그파일은 작업 실행 시마다 작업/스텝 별로 생성된다.


		logback-test.xml과 logback.xml이 같이 있는 경우 logback-test.xml이 우선 적용된다. (로컬 로그 설정용으로 사용)


	
====


.logback.xml
====

----



<configuration debug="false">

<property resource="batch.properties"/>

<turboFilter class="com.anyframe.batch.log.MDCThresholdTurboFilter">
<DefaultLevel>DEBUG</DefaultLevel>
</turboFilter>

<appender name="console" class="ch.qos.logback.core.ConsoleAppender">
<filter class="com.anyframe.batch.log.MarkerThresholdFilter">
<level>DEBUG</level>
</filter>
<encoder>
<pattern>[%d{yyyy-MM-dd HH:mm:ss}] %msg%n</pattern>
</encoder>
</appender>
  
<appender name="jobAppender" class="ch.qos.logback.classic.sift.SiftingAppender">

<filter class="com.anyframe.batch.log.MDCKeyFilter">
<key>jobLogPath</key>
<OnNoneExistKey>DENY</OnNoneExistKey>
</filter>

<discriminator>
<key>jobLogPath</key>
<defaultValue>${batch.log.directory}/job.log</defaultValue>
</discriminator>

<sift>
<appender class="ch.qos.logback.core.rolling.RollingFileAppender">
<file>${jobLogPath}</file>
<append>true</append>
<encoder>
<pattern>[%d{yyyy-MM-dd HH:mm:ss}] %-5level %logger{0} : %msg%n</pattern>
<charset>euc-kr</charset>
</encoder>

<rollingPolicy class="ch.qos.logback.core.rolling.FixedWindowRollingPolicy">
<fileNamePattern>${jobLogPath}.%i</fileNamePattern>
<minIndex>1</minIndex>
<maxIndex>1</maxIndex>
</rollingPolicy>

<triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">
<maxFileSize>5MB</maxFileSize>
</triggeringPolicy>

</appender>
</sift>
</appender>

<appender name="stepAppender" class="ch.qos.logback.classic.sift.SiftingAppender">

<filter class="com.anyframe.batch.log.MDCKeyFilter">
<key>stepLogPath</key>
<OnNoneExistKey>DENY</OnNoneExistKey>
</filter>

<discriminator>
<key>stepLogPath</key>
<defaultValue>${batch.log.directory}/step.log</defaultValue>
</discriminator>

<sift>
<appender class="ch.qos.logback.core.rolling.RollingFileAppender">
<file>${stepLogPath}</file>
<append>true</append>

<rollingPolicy class="ch.qos.logback.core.rolling.FixedWindowRollingPolicy">
<fileNamePattern>${stepLogPath}.%i</fileNamePattern>
<minIndex>1</minIndex>
<maxIndex>1</maxIndex>
</rollingPolicy>

<triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">
<maxFileSize>5MB</maxFileSize>
</triggeringPolicy>

<encoder>
<pattern>[%d{yyyy-MM-dd HH:mm:ss}] %-5level %logger{0} : %msg%n</pattern>
<charset>euc-kr</charset>
</encoder>
</appender>
</sift>
</appender>

<logger name="org.springframework" additivity="false">
<level value="info" />
<appender-ref ref="console" />
<appender-ref ref="jobAppender"/>
</logger>

<logger name="com.anyframe" additivity="false">
<level value="info" />
<appender-ref ref="console" />
<appender-ref ref="jobAppender"/>
</logger>

<logger name="com.anyframe.batch.core.step.AbstractStep" additivity="false">
<level value="info" />
<appender-ref ref="console" />
<appender-ref ref="stepAppender"/>
<appender-ref ref="jobAppender"/>
</logger>

<logger name="com.anyframe.batch.core.step.support.StepLoggingListener" additivity="false">
<level value="info" />
<appender-ref ref="console" />
<appender-ref ref="stepAppender"/>
<appender-ref ref="jobAppender"/>
</logger>

<logger name="StaticScriptLogger" additivity="false">
<level value="debug" />
<appender-ref ref="console" />
<appender-ref ref="stepAppender"/>
</logger>

<!-- logger for stdout, stderr stream of shell script -->
<logger name="ShellScriptLogger" additivity="false">
<level value="debug" />
<appender-ref ref="console" />
<appender-ref ref="stepAppender"/>
</logger>

<!-- logger for Reader/Writer -->
<logger name="ItemLogger" additivity="false">
<level value="debug" />
<appender-ref ref="console" />
<appender-ref ref="stepAppender"/>
</logger>

<!-- logger for loading query -->
<logger name="StaticQueryLogger" additivity="false">
<level value="debug" />
<appender-ref ref="console" />
<appender-ref ref="stepAppender"/>
</logger>

<!-- FOR ONLINE DAO -->
<logger name="org.anyframe.jdbc.support.CompleteQueryPostProcessor" additivity="false">
<level value="error" />
<appender-ref ref="console" />
<appender-ref ref="stepAppender"/>
</logger>

<!-- FOR VOUTIL DEBUG -->
<logger name="com.anyframe.online.util.VoUtil" additivity="false">
<level value="debug"/>
<appender-ref ref="console" />
<appender-ref ref="stepAppender" />
</logger>

<!-- logger for batch result message -->
<logger name="MessageLogger" additivity="false">
<level value="debug" />
<appender-ref ref="console" />
<appender-ref ref="stepAppender"/>
</logger>

<root level="debug">
<appender-ref ref="console" />
<appender-ref ref="stepAppender"/>
</root>

</configuration>


----


====

.logback-test.xml
====

----



<configuration debug="false">

<appender name="console" class="ch.qos.logback.core.ConsoleAppender">
<encoder>
<pattern>[%d{yyyy-MM-dd HH:mm:ss}] %t %-5level %logger{0} : %msg%n</pattern>
</encoder>
</appender>
  
<logger name="org.springframework" level="info" />

<logger name="com.anyframe" level="info" />

<!-- FOR ONLINE DAO -->
<logger name="org.anyframe.jdbc.support.CompleteQueryPostProcessor" level="error" />

<!-- FOR VOUTIL DEBUG -->
<logger name="com.anyframe.online.util.VoUtil" level="debug" />

<logger name="StaticScriptLogger" level="debug" />

<!-- logger for stdout, stderr stream of shell script -->
<logger name="ShellScriptLogger" level="debug" />

<!-- logger for Reader/Writer -->
<logger name="ItemLogger" level="debug" />

<!-- logger for loading query -->
<logger name="StaticQueryLogger" level="debug" />

<!-- logger for MessageFormatter which logs batch job result -->
<logger name="MessageLogger" level="debug" />

<root level="debug">
<appender-ref ref="console" />
</root>

</configuration>


----


====


[NOTE]
====

		batch.log.directory 경로 하위에 생성되는 경로를 customizing 가능한 구조를 지원한다. 
		기본적으로 제공된 종류는 다음과 같다. 
		
		- DummyLogPathGenerator - default 경로 유지
		- ParamLogPathGenerator - 작업 실행 이전에 Job Parameter 로 부터 로그 경로 변경 
		- OptionLogPathGenerator - 작업 실행 이전에 Job Option 으로 부터 로그 경로 변경
	    - ( keys property 에 선언된 키 값을 기준으로 로그 경로 변경 )

	
====

.context-batch-runtime.xml ( log 경로 customizing )
====

----

<!-- job operator for normal batch synchronous -->
<bean id="jobOperator" class="com.anyframe.batch.launch.DefaultJobOperator">
	<property name="jobRepository" ref="jobRepository"/>
	<property name="jobLocator" ref="jobLocator"/>
	<property name="jobLauncher">
		<bean class="com.anyframe.batch.launch.DefaultJobLauncher">
			<property name="jobRepository" ref="jobRepository"/>
		</bean>
	</property>
	<property name="jobMetaResolver" ref="jobMetaResolver"/>
	<property name="logPathGenerator" ref="logPathGenerator"/>
</bean>

<!-- job operator for online batch asynchronous -->
<bean id="jobOperatorAsync" class="com.anyframe.batch.launch.DefaultJobOperator">
	<property name="jobRepository" ref="jobRepository"/>
	<property name="jobLocator" ref="jobLocator"/>
	<property name="jobLauncher">
		<bean class="com.anyframe.batch.launch.DefaultJobLauncher">
			<property name="jobRepository" ref="jobRepository"/>
			<property name="taskExecutor">
				<bean class="org.springframework.core.task.SimpleAsyncTaskExecutor">
					<property name="threadNamePrefix" value="job-thread"/>
					<property name="daemon" value="true"/>
				</bean>
			</property>
		</bean>
	</property>
	<property name="jobMetaResolver" ref="jobMetaResolver"/>
	<property name="logPathGenerator" ref="logPathGenerator"/>
</bean>

<bean id="logPathGenerator" class="com.anyframe.batch.launch.support.OptionLogPathGenerator">
	<property name="keys" value="TENKEY,KEY1" />
</bean>

----

====


[[runtime-install-lib]]


==== 라이브러리 목록(lib)

:: lib 폴더에는 배치 실행에 필요한 라이브러리(jar)를 포함하고 있다.


[NOTE]
====

		업무적으로 추가 라이브러리가 필요한 경우 해당 라이브러리 파일을 lib 폴더에 위치하면 된다.


	
====


[options="header"]
|===============
^|라이브러리 ^|설명 
|activation-1.1.jar |임의 데이터의 타입을 정의하기 위한 표준 서비스를 제공 
|anyframe-batch-interface-5.2.0.jar |batch runtime, agent, admin에서 공용으로 사용하는 interface 
|anyframe-core.jar |Anyframe 코어 라이브러리 
|anyframe-online-core.jar |Annotation, charset, 유틸리티 등 온라인 프레임워크에서 사용하는 기본 타입이나 기능을 정의 
|anyframe-platform-monitoring-sun-1.0.jar |SUN JVM을 모니터링하기 위한 기능을 제공 
|aopalliance-1.0.jar |AOP를 사용하기 위해 필요한 라이브러리로 Advice용 Class 작성 시 사용됨 
|asm-4.2.jar |Java bytecode 조작을 위한 기능을 제공 
|aspectjweaver-1.6.11.jar |AOP를 사용하기 위해 필요한 라이브러리 
|cal10n-api-0.8.1.jar |국제화(Internationalization) 관련 기능 제공 
|cglib-nodep-2.2.jar |ASM 모듈이 포함되어 있는 코드 생성 라이브러리. 런타임에 동적으로 Java 클래스의 프록시를 생성함 
|commons-collections-3.2.2.jar |Java Collection 지원 라이브러리 
|commons-compiler-2.6.1.jar |Java 클래스 파일이나 Java Expression을 컴파일할 수 있는 컴파일러 
|commons-dbcp2-2.0.jar |DB connection pool 사용을 위한 라이브러리 
|commons-io-2.4.jar |I/O 기능 개발을 지원하기 위한 유틸리티 라이브러리 
|commons-lang-2.6.jar |Java Data Type별 유틸리티 라이브러리 
|commons-logging-1.2.jar |log API 라이브러리 
|commons-pool2-2.2.jar |DB connection pool 사용을 위한 라이브러리 
|ehcache-core-2.5.0.jar |데이터 캐슁을 위해 EhCache를 사용하기위한 기능을 제공 
|guava-12.0.jar |spring integration jdbc 라이브러리 사용을 위해 필요한 기능을 제공
|hessian-3.2.0.jar |agent와 communication을 위한 hessian 프로토콜 라이브러리 
|hsqldb-2.3.2.jar |HSQLDB 사용을 위한 라이브러리 
|jackson-core-asl-2.2.2.jar |JSON 처리를 위한 라이브러리 (parser, generator) 
|jackson-mapper-asl-1.9.7.jar |JSON 처리를 위한 라이브러리 (data binding) 
|jackson-xc-1.9.7.jar |JSON 처리를 위한 라이브러리 (JSON processor의 data binding의 상호운용성을 제공하는 확장
						라이브러리) 
|janino-2.6.1.jar |Java Compiler 
|jasypt-1.7.jar |암복호화 라이브러리(jdbc.properties의 패스워드 암호화) 
|jaxb-api-2.2.jar |XML과 Java 객체간의 변환을 위한 기능 제공 
|jcl-over-slf4j-1.6.4.jar |JCL(Jakarta commons logging)에 종속적인 클래스에 영향없이 로깅 API가 slf4j API를 호출하도록 해주는
						어댑터 
|jettison-1.1.jar |spring batch core 라이브러리 사용을 위해 필요한 기능을 제공 
|joda-time-2.4.jar |Advanced Java Date/Time API를 제공 
|jsr305-1.3.9.jar |spring integration jdbc 라이브러리 사용을 위해 필요한 기능을 제공
|junit-4.4.jar |단위 테스트 프레임워크  
|log4j-over-slf4j-1.6.4.jar |log4j에 의존적인 코드를 내부적으로는 slf4j가 동작하도록 해주는 라이브러리 
|logback-classic-1.0.7.jar |slf4j에서 Logback 사용이 가능하도록 만든 플러그인 컴포넌트 
|logback-core-1.0.7.jar |Logback의 핵심 기능을 제공하는 라이브러리 
|mysql-connector-java-5.1.37.jar |Mysql JDBC 드라이버 
|ojdbc6-11.2.0.2.0.jar |Oracle JDBC 드라이버 
|postgresql-9.0-801.jar |Postgresql JDBC 드라이버 
|servlet-api-3.0-alpha-1.jar |서블릿 API를 제공하는 라이브러리 3.0
|servlet-api.jar |서블릿 API를 제공하는 라이브러리 2.5
|slf4j-api-1.7.19.jar |slf4j 의 API를 제공하는 라이브러리 
|slf4j-ext-1.7.19.jar |SLF4J 확장 기능 제공 (Profiler, Extended Logger 등) 
|spring-aop-4.2.3.RELEASE.jar |Spring AOP 라이브러리 
|spring-aspects-4.2.3.RELEASE.jar |Spring Aspect 관련 기능 제공  
|spring-batch-core-2.2.6.jar |Spring 배치 핵심 기능 제공 
|spring-batch-infrastructure-2.2.6.jar |배치 어플리케이션과 최적화를 위한 low-level 컴포넌트, 인터페이스, Tool을 제공 
|spring-beans-4.2.3.RELEASE.jar |Java Bean, Bean 컨테이너 관련 라이브러리 
|spring-context-4.2.3.RELEASE.jar |어플리케이션 컨텍스트 관련 라이브러리 
|spring-context-support-4.2.3.RELEASE.jar |Quartz와 CommonJ 스케쥴링, UI 템플릿, 메일, 캐슁 관련 라이브러리 
|spring-core-4.2.3.RELEASE.jar |Spring 코어, 소스레벨의 메타데이터 및 ASM 라이브러리 재패키징 
|spring-expression-4.2.3.RELEASE.jar |Spring 표현언어 (SpEL) 지원 클래스 포함 
|spring-integration-core-3.0.2.RELEASE.jar |Spring Integration의 코어 모듈 
|spring-integration-file-3.0.2.RELEASE.jar |Spring Integration File 어댑터 
|spring-integration-http-3.0.2.RELEASE.jar |Spring Integration Http 어댑터 
|spring-integration-jdbc-3.0.2.RELEASE.jar |Spring Integration JDBC support 
|spring-jdbc-4.2.3.RELEASE.jar |JDBC 지원 
|spring-orm-4.2.3.RELEASE.jar |JDO, JPA, Hibernate, iBatis등 지원 
|spring-oxm-4.2.3.RELEASE.jar |XML과 Java 객체간의 serialize 기능을 제공  
|spring-retry-1.0.2.RELEASE.jar |retry 관련 기능을 제공
|spring-test-4.2.3.RELEASE.jar |테스트 컨텍스트 프레임워크 다양한 Mock 지원 클래스 (Servlet API, JUnit 지원) 
|spring-tx-4.2.3.RELEASE.jar |트랜잭션 인프라 JCA 지원, DAO 지원 
|spring-web-4.2.3.RELEASE.jar |웹 어플리케이션 컨텍스트, 파일 업로드 처리, HTTP 기반 원격지원 
|spring-webmvc-4.2.3.RELEASE.jar |프레임워크 서블릿, MVC 프레임워크, WEB 컨트롤러와 뷰 제공 
|validation-api-1.0.0.GA.jar |Bean에 대한 validation API 
|xpp3_min-1.1.3.3.jar |XML Full Parser 
|xstream-1.3.1.jar |XML과 Java 객체간의 serialize 기능을 제공  

|===============


[[runtime-run]]


=== 기동 및 중지

:: 다음 명령어(쉘)를 실행함으로써 배치 런타임(작업)을 기동/중지할 수 있다.

.작업 실행
====

----



RUNTIME_HOME/bin/runjob.sh <job_location> [parameter]... [options]...

Usage:
runjob.sh sample/batch/hello_cfg.xml
runjob.sh sample/batch/hello_cfg.xml TODAY=20130402 BASE_DIR=/sample
runjob.sh sample/batch/hello_cfg.xml TODAY=20130402 -LEVEL=DEBUG

Options:
-JOBKEY=<KEY>             작업에 대한 외부 고유 식별자를 지정(문자열)
-CONFIG=<LOCATION>        로딩할 Bean 설정 위치 [default: classpath:spring/context-*.xml]
-PROFILE=<PROFILE>        작업 실행 시 적용할 Profile
-LEVEL=(DEBUG|INFO|ERROR) 적용할 로그레벨
-JOBAPPLICATION=<CFG목록> 작업 완료 이후에 수행될 작업 목록을 지정
-STEP_FROM=<STEP명>       cfg 내에 최초 실행할 step 지정
-STEP_TO=<STEP명>         cfg 내에 최후 실행할 step 지정
-CONCURRENT=(true/false)  해당 작업 동시 실행 여부 지정


----


====

.작업 중지
====

----



RUNTIME_HOME/bin/killjob.sh <process_id>

Usage:
killjob 153248

----


====

[[runtime-architecture]]


=== Runtime Reference

:: [[runtime-architecture-create]]


==== 작업 생성 구조

:: 작업 실행 전, Job이나 Step에 대한 객체 생성은 JobFactory와 StepFactory가 담당하며, 작업정의(_cfg.xml) 파일을 load할 때 &lt;job&gt; 태그의 내용을 parsing하기 위한 JobParser 클래스가 CoreNamespaceHandler에 의해 등록된다.

JobParser를 통해 xml의 각 엘리먼트의 내용이 BeanDefinitionBuilder에 저장되며, &lt;step&gt; 태그의 경우, StepParser에 의해 분석된다.

또한, BeanDefinitionBuilder에 FactoryBean으로 JobFactory와 StepFactory, ResourceFactory를 각각 등록하여, 실제 context에서 Job 객체나 Step 객체 획득 시, JobFactory와 StepFactory, ResourceFactory의 getObject() 메소드를 통하여 각각의 객체를 획득한다.



image::images/runtime-architecture-job.png[align="center"]

[[runtime-architecture-create-job]]


===== Job 객체 생성(JobFactory)

:: JobFactory는 Job 객체 생성을 담당한다.

JobFactory는 아래와 같은 설정정보를 참고하여, Job 객체를 생성한다.

* jobRepository - Job 정보를 관리하는 Job Repository 생성정보를 정의함

* autoConfigListener - JobExecutionListener를 자동으로 감지하여 설정할지 여부

* concurrent - Job의 동시실행 가능여부에 대한 default 설정값

* restartable - Job의 재시작 가능여부에 대한 default 설정값

[NOTE]
====

		JobFactory가 생성하는 AbstractJob 객체에는 JobFactory에 정의된 값 이외에, Job 실행 전/후처리를 담당하는 JobExecutionListener도 저장되는데, 이 Listener들은 JobFactory에서 어플리케이션 컨텍스트 초기화 시 JobExecutionListener의 구현 클래스를 찾아 등록한다. (autoConfigListener이 "true"인 경우)


	
====

JobRepository는 아래과 같은 설정정보를 참고한다. 

* dataSource - Batch Meta 정보를 저장하는 Datasource 정보

* persist - Batch Meta 정보 datasource 사용 여부

* defaultCurrentCountForStepComplete - Step 정상완료시 Step 진행상황 강제 업데이트 값 

* jobExecutionKeyGenerator - Job 명 이외의 Sub-key 생성 방식 설정 ( 동시 실행 여부 체크시 참조 )

[NOTE]
====

		JobExecutionKeyGenerator 의 경우 Job 명 이외의 sub-key 값을 생성하여 동시 실행 여부 체크시 참조 하며, 아래의 세가지 를 정의할 수 있다. 
		
		- DummyJobExecutionKeyGenerator - Sub-key 사용 안함 [ default ]
		- ParamJobExecutionKeyGenerator - 작업 실행 이전에 Job Parameter 로 부터  Sub-key 생성 
		- OptionJobExecutionKeyGenerator - 작업 실행 이전에 Job Option 으로부터 Sub-key 생성
		- ( keys property 에 선언된 키 값을 기준으로 생성 )


	
====


.context-batch-runtime.xml
====

----



<bean id="com.anyframe.batch.jobFactory" class="com.anyframe.batch.core.job.factory.JobFactory">
	<property name="jobRepository" ref="jobRepository" />
	<property name="autoConfigListener" value="true"/>
	<property name="concurrent" value="false"/>
	<!-- default restartable of job -->
	<property name="restartable" value="${batch.job.restartable}"/>
</bean>

<bean id="jobRepository" class="com.anyframe.batch.core.repository.support.JobRepositoryFactory">
	<property name="dataSource" ref="DS_FRAMEWORK"/>
	<property name="maxVarCharLength" value="2000"/>
	<property name="persist" value="${batch.database.persist}"/>
	<property name="databaseType" value="${batch.database.type}"/>
	<property name="serializer">
	<!-- default java serializer with BASE64 encoding -->
		<bean class="com.anyframe.batch.core.repository.support.DefaultExecutionContextSerializer"/>
	</property>
	<property name="lobHandler">
		<bean class="org.springframework.jdbc.support.lob.DefaultLobHandler"	/>
	</property>
	<property name="defaultCurrentCountForStepComplete" value="100"/>
	<property name="jobExecutionKeyGenerator" ref="jobExecutionKeyGenerator"/>
</bean>

<bean id="jobExecutionKeyGenerator" class="com.anyframe.batch.core.repository.support.OptionJobExecutionKeyGenerator">
	<property name="keys" value="TENANTKEY,KEY1"/>
</bean>


----


====


[NOTE]
====

		${batch.XX}로 정의된 속성 값은 batch.properties에 정의된다.


	
====


[[runtime-architecture-create-step]]


===== Step 객체 생성(StepFactory)

:: StepFactory는 Step 객체 생성을 담당하며, 기본적으로 CompositeStepFactory를 사용한다.

CompositeStepFactory는 아래와 같은 설정정보를 참고하여, 유형별로 지정된 StepFactory를 호출하여 Step 객체를 생성한다.

* jobRepository - Job 정보를 관리하는 Job Repository 생성정보를 정의함

* autoConfigListener - StepExecutionListener를 자동으로 감지하여 설정할지 여부

* factoryMap - Step 유형에 StepFactory 맵핑

[options="header"]
|===============
^|유형 ^|StepFactory ^|Property 
|java |TaskStepFactory |* resourceFactory - java 스텝에서 사용하는 resource 객체생성을 담당하는 FactoryBean

* transactionManager - 트랜잭션 매니저 Bean 설정

* restartable - Step의 재시작 가능여부 설정

* creatable - ItemReader/Writer 동적생성 가능 여부

 
|parallel |ParallelStepFactory |* maxThread - Step 병렬처리시 동시 실행 가능한 Thread 최대 수

* restartable - Step의 재시작 가능여부 설정

 
|delete |DeleteStepFactory |* restartable - Step의 재시작 가능여부 설정

 
|shell |ShellStepFactory |* fileNameGenerator - script를 실행할 shell file을 생성시 filename 생성 관련 Bean 설정

* command - shell 을 실행할 명령어 위치

* options - shell 실행 시 option

* commentPrefix - shell 실행 시, skip 할 주석(comment)의 시작 표시

* restartable - Step의 재시작 가능여부 설정

 

|===============


.context-batch-runtime.xml
====

----



<bean id="com.anyframe.batch.stepFactory" class="com.anyframe.batch.core.step.factory.CompositeStepFactory">
  <property name="jobRepository" ref="jobRepository" />
  <property name="autoConfigListener" value="true"  />
  <property name="factoryMap">
    <map>
      <entry key="java">
        <bean class="com.anyframe.batch.core.step.factory.TaskStepFactory">
          <property name="resourceFactory" ref="com.anyframe.batch.resourceFactory"/>
          <property name="transactionManager" ref="transactionManager" />
          <property name="restartable" value="${batch.step.restartable}"/>
          <property name="creatable" value="false"/>
        </bean>
      </entry>
      
      <entry key="parallel">
        <bean class="com.anyframe.batch.core.step.factory.ParallelStepFactory">
          <property name="maxThread" value="${batch.step.parallel.max}"/>
          <property name="restartable" value="${batch.step.restartable}"/>
        </bean>
      </entry>
      
      <entry key="delete">
        <bean class="com.anyframe.batch.core.step.factory.DeleteStepFactory">
          <property name="restartable" value="${batch.step.restartable}"/>
        </bean>
      </entry>
      
      <entry key="shell">
        <bean class="com.anyframe.batch.core.step.factory.ShellStepFactory">
          <property name="fileNameGenerator">
          <bean class="com.anyframe.batch.core.step.support.DefaultFileNameGenerator">
              <property name="baseDir" value="${batch.log.directory}"/>
              <property name="extention" value=".sh"/>
          </bean>
          </property>
          <property name="command" value="/usr/bin/sh"/>
          <property name="options" value=""/>
          <property name="commentPrefix" value="#"/>
          <property name="restartable" value="${batch.step.restartable}"/>
        </bean>
      </entry>
    </map>
  </property>
</bean>


----


====


[NOTE]
====

		${batch.XX}로 정의된 속성 값은 batch.properties에 정의된다.


	
====


[[runtime-architecture-create-resource]]


===== Resource 객체 생성(ResourceFactory)

:: ResourceFactory는 Resource 객체 생성을 담당하며, 기본적으로 CompositeResourceFactory를 사용한다.

CompositeResourceFactory 유형별로 지정된 ResourceFactory를 호출하여 Resource 객체를 생성한다.

각 ResourceFactory에 정의한 속성들은 default 값이 되며, ResourceFactory.getObject() 메소드를 통해 Resource 객체 생성 시점에는 각 작업정의(CFG)에 정의된 리소스의 속성이 우선적으로 설정된다.

[options="header"]
|===============
^|유형 ^|ResourceFactory 
|SAM |ByteResourceFactory 
|VSAM |StringResourceFactory 
|DB |DatabaseResourceFactory 
|XML |XmlResourceFactory 
|DAO |MethodResourceFactory 

|===============


.context-batch-runtime.xml
====

----



<bean id="com.anyframe.batch.resourceFactory" class="com.anyframe.batch.infra.factory.CompositeResourceFactory">
  <property name="factoryMap">
    <map>
      <entry key="SAM">
        <bean class="com.anyframe.batch.infra.factory.ByteResourceFactory">
          <property name="resourceType">
            <value type="com.anyframe.batch.config.BatchResource$ResourceType">FILE</value>
          </property>
          <property name="encoding" value="${batch.file.encoding}"/>
          <property name="deleteEmpty" value="${batch.writer.file.delete.empty}"/>
          <property name="trim" value="${batch.reader.sam.trim}"/>
          <property name="maxSize" value="${batch.writer.file.max}"/>
          <property name="bufferSize" value="${batch.file.buffersize}"/>
          <property name="useTemp" value="${batch.writer.file.temp}"/>
          <property name="tempSuffix" value="${batch.writer.file.temp.suffix}"/>
          <property name="overWrite" value="${batch.writer.file.overwrite}"/>
          <property name="fixed" value="${batch.reader.sam.fixed}"/>
          <property name="null" value="${batch.item.null}"/>
          <property name="overflow" value="${batch.charset.overflow}"/>
          <property name="malformed" value="${batch.charset.malformed}"/>
          <property name="unmappable" value="${batch.charset.unmappable}"/>
          <property name="transformFactory">
            <bean class="com.anyframe.batch.vo.transform.TransformByteFactory">
              <property name="useProxy" value="true"/>
              <property name="charsetFactory">
                <bean class="com.anyframe.batch.vo.charset.CustomCharsetFactory"/>
              </property>
            </bean>
          </property>
        </bean>
      </entry>
    
      <entry key="VSAM">
        <bean class="com.anyframe.batch.infra.factory.StringResourceFactory">
          <property name="resourceType">
            <value type="com.anyframe.batch.config.BatchResource$ResourceType">FILE</value>
          </property>
          <property name="encoding" value="${batch.file.encoding}"/>
          <property name="deleteEmpty" value="${batch.writer.file.delete.empty}"/>
          <property name="trim" value="${batch.reader.vsam.trim}"/>
          <property name="maxSize" value="${batch.writer.file.max}"/>
          <property name="bufferSize" value="${batch.file.buffersize}"/>
          <property name="useTemp" value="${batch.writer.file.temp}"/>
          <property name="tempSuffix" value="${batch.writer.file.temp.suffix}"/>
          <property name="overWrite" value="${batch.writer.file.overwrite}"/>
          <property name="escape" value="${batch.vsam.escape}"/>
          <property name="null" value="${batch.item.null}"/>
          <property name="overflow" value="${batch.charset.overflow}"/>
          <property name="malformed" value="${batch.charset.malformed}"/>
          <property name="unmappable" value="${batch.charset.unmappable}"/>
          <property name="transformFactory">
            <bean class="com.anyframe.batch.vo.transform.TransformStringFactory">
              <property name="useProxy" value="true"/>
            </bean>
          </property>
        </bean>
      </entry>
    
      <entry key="DB">
        <bean class="com.anyframe.batch.infra.factory.DatabaseResourceFactory">
          <property name="resourceType">
            <value type="com.anyframe.batch.config.BatchResource$ResourceType">DB</value>
          </property>
          <property name="fetchSize" value="1000"/>
          <property name="batchUpdate" value="false"/>
          <property name="allowCustomQuery" value="${batch.sql.allow.custom}"/>
          <property name="trim" value="${batch.reader.db.trim}"/>
          <property name="null" value="${batch.item.null}"/>
          <property name="transformFactory">
            <bean class="com.anyframe.batch.vo.transform.TransformJdbcFactory"/>
          </property>
        </bean>
      </entry>
    
      <entry key="XML">
        <bean class="com.anyframe.batch.infra.factory.XmlResourceFactory">
          <property name="resourceType">
            <value type="com.anyframe.batch.config.BatchResource$ResourceType">FILE</value>
          </property>
          <property name="maxSize" value="${batch.writer.file.max}"/>
          <property name="bufferSize" value="${batch.file.buffersize}"/>
          <property name="useTemp" value="${batch.writer.file.temp}"/>
          <property name="tempSuffix" value="${batch.writer.file.temp.suffix}"/>
          <property name="overWrite" value="${batch.writer.file.overwrite}"/>
        </bean>
      </entry>
    
      <entry key="DAO">
        <bean class="com.anyframe.batch.infra.factory.MethodResourceFactory">
          <property name="resourceType">
            <value type="com.anyframe.batch.config.BatchResource$ResourceType">DB</value>
          </property>
          <property name="factoryMethod" value="getInstance"/>
        </bean>
      </entry>
    </map>
  </property>
</bean>


----


====


[NOTE]
====

		${batch.XX}로 정의된 속성 값은 batch.properties에 정의된다.


	
====


[[runtime-architecture-run]]


==== Job 실행 구조

:: 생성된 작업객체(AbstractJob)은 DefaultJobLauncher에서 AbstractJob의 execute() 메소드를 호출하여 Job 실행이 시작된다.



image::images/runtime-architecture-job-run.png[align="center"]


. DefaultJobLauncher는 AbstractJob의 execute() 메소드를 호출


. AbstractJob은 JobExecution 에 startTime(현재시간), status(STARTED)를 저장한다.


. ExecutionContext에 Job Parameter 설정을 저장한다.
::
Job Parameter는 작업정의(CFG)에 정의되거나, 실행 커맨드의 옵션 등으로 지정할 수 있다.


. 등록된 JobExecutionListener의 beforeJob() 메소드 호출


. SimpleStepHandler.handleStep() 메소드를 호출하여, Job에 포함된 Step들을 실행


. 각 Step의 실행이 끝나면, JobExecution에 endTime(현재시간), status(COMPLETED)를 저장한다.


. 등록된 JobExecutionListener의 afterJob() 메소드 호출


. JobRepository를 통해 Job의 실행정보를 update한다.

[[runtime-architecture-run-step]]


==== Step 실행 구조

:: 

image::images/runtime-architecture-step-run.png[align="center"]


. AbstractJob에서 Job에 포함된 Step의 수만큼 SimpleStepHandler의 handleStep() 메소드를 호출한다.


. SimpleStepHandler는 DB로부터 해당 Job의 마지막 Step 정보를 조회하고, 아래와 같은 조건이면 수행되어야 하는 Step이므로 Step 실행을 정상적으로 진행한다.

. Step 정보가 존재하지 않으면, 최초 실행되는 Step 임


. Step 정보가 존재하나 Step의 상태가 COMPLETED가 아닌 경우


. Step의 상태를 STARTED로 변경하고, Step 정보를 DB에 업데이트한다.


. Step의 execute() 메소드를 호출한다.


. TaskStep, ParallelStep, DeleteStep, ShellStep 등 모든 Step의 상위 클래스인 AbstractStep의 execute() 메소드를 호출한다. Step의 시작시간을 현재시간으로 설정한다.


. Step에 설정된 Listener에 대하여 beforeStep() 메소드를 수행한다.

. Java Step의 경우, 별도 정의된 Listener 이외에도, Java Step에서 수행하는 Java 프로그램 자체가 StepExecutionListener를 구현하고 있는 구현체이므로, 업무팀에서 개발한 Java 프로그램에 정의된 beforeStep()과 이후 afterStep()도 수행된다.


. Resource 정보를 DB에 저장한다.

. 컨텍스트에 저장되어 있는 Resource 정보가 이미 DB에 있는 정보인 경우, 정보를 업데이트하고, DB에 없는 Resource인 경우, 신규로 insert한다.


. 신규 insert하는 정보는 jobId, stepId, resourceName, resourceUrl, ResourceStatus.LOCKED, resourceType, resourceMethod, 생성시간(현재시간), 수정시간(현재시간)이다.


. 기존에 존재하는 Resource에 대하여 업데이트하는 정보는 resourceUrl, ResourceStatus.LOCKED, 수정시간(현재시간) 이다.


. 각 Step의 open() 메소드를 수행하여 Step에서 사용하는 리소스들을 초기화한다.


. 각 Step에 적합한 doExecute() 메소드를 수행한다.


. 각 Step 수행이 끝나면, Step에 설정된 Listener에 대하여 afterStep() 메소드를 수행한다.


. Step 정보와 Resource 정보를 업데이트한다.

. Step : 상태(정상종료=BatchStatus.COMPLETED, 오류= BatchStatus.FAILED, 중지= BatchStatus.STOPPED) , 수정시간(현재시간), 종료 Description, totalCount, currenCount, commitCount, stepId


. Resource : 상태(ResourceStatus.RELEASED), resourceCount, 수정시간(현재시간)

[[runtime-architecture-run-step-task]]


===== TaskStep 실행

:: TaskStep은 Step의 유형이 java인 경우이며, doExecute()에서는 다음과 같은 순서로 Step이 수행된다.


. context-batch-runtime.xml에 정의된 transactionManager로 트랜잭션을 start한다.


. 작업정의(CFG)에 java step의 @class로 설정된 class의 execute() 메소드를 실행한다.

. execute() 메소드 실행 시 전달되는 입력인자는 ItemFactory 의 구현체인 TaskContextImpl 객체이다.


. TaskContextImpl 객체는 Step 실행에 필요한 각종 속성 및 컨텍스트 정보를 포함하고 있다.


. 메소드 실행이 정상적으로 종료되면 트랜잭션을 commit하고, ExitStatus.COMPLETED 를 리턴한다.

. StepExecution의 CommitCount를 1 증가시킨다.


. Step에서 사용한 ItemWriter를 flush한다.


. itemStream.update()


. 트랜잭션 commit


. Job/Step/Resource의 다음 내용을 update한다.
* Job : short_context, serialized_context

* Step : short_context, serialized_context

* Resource : commit_pos, commit_count, update_time(현재시간)


. execute() 메소드 수행 중 에러가 발생하면, 트랜잭션을 롤백 후, UnexpectedJobExecutionException을 throw한다. 메소드 수행 중 외부(batch admin, batch manager)로부터 Step 중지 요청이 들어와JobStoppingException이 발생하면, 트랜잭션 롤백 후, JobInterruptedException을 발생시킨다.

[[runtime-architecture-run-step-parallel]]


===== ParallelStep 실행

:: ParallelStep은 Step의 유형이 parallel인 경우이며, doExecute()에서는 다음과 같은 순서로 Step이 수행된다.


. ThreadPoolExecutor를 사용하여 ParallelStep에 포함된 개별 Step들을 동시에 실행시키며, 각 Step은 StepHandler.handleStep() 메소드를 호출하여 실행된다.


. 각 Step의 수행이 모두 정상 종료되면, ExitStatus.COMPLETED을 리턴하고, Step의 수행결과 상태가 COMPLETED가 아니거나 Step 수행 시 에러가 발생한 경우에는 Exception을 발생시킨다.

[[runtime-architecture-run-step-delete]]


===== DeleteStep 실행

:: DeleteStep은 Step의 유형이 "delete"인 경우이며, doExecute()에서는 다음과 같은 순서로 Step이 수행된다.


. DeleteStep내에 정의된 Resource들에 대하여 file.delete()를 수행하고, 정상 종료된 경우 ExitStatus.COMPLETED를 리턴한다.


. 정의된 url에 해당하는 파일이 없는 경우, "file does not exist: " 라는 info 레벨의 로그를 찍고 ExitStatus.COMPLETED를 리턴한다.

[[runtime-architecture-run-step-shell]]


===== ShellStep 실행

:: ShellStep은 Step의 유형이 "shell"인 경우이며, doExecute()에서는 다음과 같은 순서로 Step이 수행된다.


. ShellStep의 경우, StepExecutionListener의 구현체이기도 하므로, Step 실행 전에 beforeStep()이 실행된다. beforeStep()은 ShellStepFactory Bean 설정 시 scriptResolver가 정의되어 있는 경우, scriptResolver를 동작시킨다.


. 기 정의된 preScript나 postScript가 있는 경우, 작업정의(CFG)의 Shell 수텝에 명시된 script의 앞 뒤에 해당 스크립트를 append한다. (preScript나 postScript는 context-batch-runtime.xml의 ShellStepFactory 설정에 정의할 수 있음)


. script를 실행할 shell file을 생성한다. 이때, ShellStepFactory Bean 설정 시 정의된 fileNameGenerator가 사용된다. 해당 파일이 기 존재하는 경우에는 삭제한다.


. 정의한 script의 내용을 2)에서 생성한 파일에 write한다.


. ShellStepFactory Bean 설정 시 정의된 command로 해당 shell을 실행시킨다.


. shell의 수행결과가 "0"인 경우, 정상종료로 판단하여 ExitStatus.COMPLETED를 리턴하고, \ 그 이외의 경우는 실패로 판단하여 UnexpectedJobExecutionException을 리턴한다.


. 임시로 생성한 Script 실행 파일을 삭제한다.

[[runtime-architecture-resource]]


==== Reader &amp; Writer 구조

:: 배치 프로그램(Java Step)에서는 입출력 데이터를 처리하기 위해 CFG 파일에서 데이터 유형 및 포맷에 맞게 정의한 Reader, Writer를 정의하여 사용한다.

CFG 파일에 정의한 Reader, Writer는 Java Step에 정의한 클래스의 execute() 메소드의 입력 인자로 전달되는 ItemFactory의 getItemReader(), getItemWriter()를 호출하여 획득할 수 있다.

리소스 별 ItemReader/Writer 객체는 StepParser에서 CFG 파일을 파싱하는 시점에 ResourceFactory에 의해 각 유형에 적합한 객체로 생성된다.

.작업정의(CFG)
====

----



<job>

    <parameters>
        <parameter key="base" value="/sample/batch"/> 
    </parameters>
    
    <step id="step1" type="java" class="sample.batch.SimpleBat">
        <resources>
            <reader id="reader" type="SAM" url="${base}/sample1.txt" />
            <writer id="writer" type="SAM" url="${base}/sample1.out" />
        </resources>
    </step>

</job>


----


====

.java 프로그램
====

----



public class SimpleBat extends AbstractTask {

    @Override
    public void execute(ItemFactory factory) throws Exception {
    
        // XML에 정의한 id를 가지고 reader/writer 획득
    
        ItemWriter writer = factory.getItemWriter("writer");
        ItemReader reader = factory.getItemReader("reader", SampleVo.class);
   
        ... ...
        ... ...
        
    }

}


----


====

[[runtime-architecture-resource-reader]]


===== ItemReader

:: * ItemReader는 입력 File이나 DB로부터 데이터를 읽어서 프로그램 내에서 사용할 수 있는 데이터 객체(VO)로 변환하는 역할을 수행한다.

* next()를 호출하여 데이터를 읽는 위치(row)를 증가시킬 수 있으며, isLast()를 활용하여 입력 데이터의 마지막 여부를 확인할 수 있다.

* 입력 데이터를 VO로 변환하기 위해서는 setMapping()을 호출하여 매핑할 VO 클래스를 지정해야 하며, 매핑 클래스를 변경하여 입력 데이터를 다양한 객체로 변환할 수 있다.

* CFG 파일에 정의된 각 resource의 type에 따라 내부적으로 생성되는 Reader의 종류와 클래스간 관계는 아래 그림과 같다.



image::images/runtime-architecture-reader.png[align="center"]

[[runtime-architecture-resource-reader-sql]]


====== SQLReader

:: * SQLReader는 리소스의 유형이 "DB"인 경우, DatabaseResourceFactory에 의해 생성되는 ItemReader 이다.

* SQLReader를 사용하여 DB 테이블로부터 데이터를 조회하고자 하는 경우, 아래와 같이 XML에 관련설정을 하거나, Java 프로그램 내에서 API를 사용하여 설정할 수 있다.

.작업정의(CFG)
====

----



<reader id="dbreader1"  type="DB" url="default"/>
<reader id="dbreader2"  type="DB" url="default" query-id="select" mapping="com.test.TestVo">
<reader id="dbreader3"  type="DB" url="default" query="select * from table" mapping="com.test.TestVo ">
<parameters>
<parameter key="firstParameter" value="aaa"/>
<parameter key="secondParameter" value="bbb"/>
</parameters>
</reader>


----


====

.java 프로그램
====

----



public void execute(ItemFactory factory) throws Exception {

ItemReader reader01 = factory.getItemReader("reader");

reader01.setQueryPath("batch/sample/sample_sql.xml");
reader01.setQueryId("select");
reader01.setMapping(TestVo.class);
... ...
}


----


====

.주요 Attribute
[options="header"]
|===============
^|Attribute ^|설명 
|DataSource dataSource |쿼리 수행을 위한 DB접속정보를 가지고 있는 데이터소스.



CFG 파일에서 resource 정의 시 설정된 ‘url ' 속성에 따라 정해진다.


 |QueryManager queryManager |별도 Xml에 정의된 쿼리를 관리하는 객체로, 실제 구현체는 CachedXmlQueryManager이다.  
|boolean allowCustomQuery |리소스에서 사용하는 쿼리를 Java 프로그램 내부에서 수정가능한지 여부. 기본값은 false이다. 
|Object parameters |해당 리소스에 설정된 파라미터 값들 
|String queryPath |쿼리 파일의 위치. XML에 query-file 이 정의되어 있지 않은 경우, StepParser에 의해 Default로 java 클래스와 동일한 위치에 클래스명_sql.xml로 지정된다.



예) com.sample.MyBat =&gt; com/sample/MyBat_sql.xml


 |int fetchSize |데이터의 fetch 크기 
|String query |수행해야하는 쿼리 
|ParsedSql parsedSql |NamedParameter의 값으로 치환된 형식의 쿼리 문자열 
|int queryModifyCount |쿼리가 수정된 횟수 
|Class&lt;?&gt; mappingClass |쿼리 수행결과에 매핑할 VO 클래스 

|===============


.주요 Method
[options="header"]
|===============
^|Method ^|설명 
|void open(ExecutionContext) |TaskStep이 수행될 때 호출되며, CFG 파일에 정의된 값을 기준으로 아래와 같은 속성들을 셋팅한다.



. parameters, queryPath, fetchSize, query, mapping,


 |boolean next() |. DataSourceUtils.getConnection(dataSource) 으로 커넥션을 획득하고, PreparedStatement를 생성하여 쿼리를 수행한다. (최초 1회에 한함)



. 쿼리 수행 결과인 resultSet의 next()를 호출하여 커서 위치를 다음 row로 이동시킨다.


 |&lt;T&gt; T read() |. DataSourceUtils.getConnection(dataSource) 으로 커넥션을 획득하고, PreparedStatement를 생성하여 쿼리를 수행한다. (next()가 한번도 호출되지 않은 경우, 최초1회에 한함)



. resultSet으로부터 얻은 rawData를

**TransformJdbc**의 decodeVo() 메소드를 사용하여 VO객체로 변환하여 리턴한다. 이때 VO객체의 메타정보인 VoMeta 객체를 활용한다.



. ItemCount를 1 증가시킨다.


 |boolean isLast() |SQLReader에서 isLast 메소드는 성능문제의 소지가 있어 사용하지 않는다.
						UnsupportedOperationException("isLast() is unsupported operation because of
						performance.");가 발생함. 
|void setQuery(String query) |Java 프로그램 내에서 쿼리를 설정하고자 할 때 사용하며, 이 값은 allowCustomQuery가 true인 경우에만 사용이
						가능하고, allowCustomQuery가 false인 경우에는 UnsupportedOperationException이
						발생함 
|void setQueryId(String queryID) |Java 프로그램 내에서 쿼리ID를 지정하고자 할 때 사용하며, 내부적으로는 query file에서 해당 쿼리 ID를 조회하고,
						해당 쿼리가 없는 경우, BatchReaderException을 발생시키고, 해당 쿼리가 있는 경우, 실행할 Query 정보로 저장한다.
					 

|===============


[[runtime-architecture-resource-reader-byte]]


====== ByteReader

:: * ByteReader는 리소스의 유형이 ‘SAM '인 경우, ByteResourceFactory에 의해 생성되는 ItemReader 이다.

* ByteReader를 사용하여 SAM파일로부터 데이터를 조회하고자 하는 경우, 아래와 같이 XML에 관련설정을 하거나, Java 프로그램 내에서 API를 사용하여 설정할 수 있다.

.작업정의(CFG)
====

----



<reader id="reader1" type="SAM" url="${base}/input.txt" encoding="euc-kr"/>
<reader id="reader2" type="SAM" url="${base}/input.txt" show-log="true" columns="5,10,3,10,25,30,30" />


----


====

.java 프로그램
====

----



public void execute(ItemFactory factory) throws Exception {

ItemReader reader1 = factory.getItemReader("reader1");

reader1.setColumns(new int[]{5,5,10,5,20,30});
... ...
}


----


====

.주요 Attribute
[options="header"]
|===============
^|Attribute ^|설명 
|int[] columns |매핑할 VO 클래스가 별도로 정의되지 않은 경우, SAM파일의 레코드를 분리하기 위한 각 컬럼의 길이를 지정한다. 

|===============


.주요 Method
[options="header"]
|===============
^|Method ^|설명 
|void open(ExecutionContext) |TaskStep이 수행될 때 호출되며, CFG 파일에 정의된 값을 기준으로 reader의 속성들을 셋팅한다.



: mapping, columns, inputStream


 |boolean next() |. 라인 구분자(linesep)가 정의되어 있는 경우, inputStream의 readLine()을 호출하고, byte[] 형태로 리턴된 raw data를 ByteReader의 rawBuffer에 저장한다.



. inputStream의 readLine()은 Binary 파일로부터 1줄을 읽는다. 한 줄은 CR(\r)이나 LF(\n)로 끝나거나 또는 CR+LF로 끝난다.


 |&lt;T&gt; T read() |. CFG에 지정된 fixed 속성이 true인 경우, 개행문자가 반드시 지정되어 있어야 한다.



. rawBuffer로부터 얻은 byte[] 형태의 데이터를 lineBuffer로 copy하고,

**TransformByteProxy**의 decodeVo() 메소드를 사용하여 VO객체로 변환하여 리턴한다. 이때 VO객체의 메타정보인 VoMeta 객체를 활용한다.



. ItemCount (read count)를 1 증가시킨다.


 
|===============


[[runtime-architecture-resource-reader-string]]


====== StringReader

:: * StringReader는 리소스의 유형이 ‘VSAM '인 경우, StringResourceFactory에 의해 생성되는 ItemReader 이다.

* - StringReader를 사용하여 VSAM파일로부터 데이터를 조회하고자 하는 경우, 아래와 같이 XML에 관련설정을 하거나, Java 프로그램 내에서 API를 사용하여 설정할 수 있다.

.작업정의(CFG)
====

----



<reader id="reader1" type="VSAM” url="sample.txt" colsep="|" linesep="CRLF" charset="utf-8"/>
<reader id="reader2" type="VSAM” url="sample.txt" escape="true"/>


----


====

.java 프로그램
====

----



public void execute(ItemFactory factory) throws Exception {

ItemReader reader1 = factory.getItemReader("reader1");

reader1.setColumns(new int[]{5,5,10,5,20,30});
... ...
}


----


====

.주요 Method
[options="header"]
|===============
^|Method ^|설명 
|void open(ExecutionContext) |. TaskStep이 수행될 때 호출되며, CFG 파일에 정의된 값을 기준으로 reader의 속성들을 셋팅한다.



: mapping, columns, inputStream



. 정의된 charset에 해당하는 decoder를 생성한다. CFG에서 리소스 정의시 별도의 charset을 지정하지 않은 경우, AbstractFileResourceFactory의 기본값인 ‘UTF-8 '이 해당 리소스의 charset이 된다.



. 생성된 decoder를 인자로 InputStreamReader객체를 생성한다.



. InputStreamReader 객체를 기반으로 BufferedReader 객체를 생성한다.



. BufferedReader객체와 정의된 컬럼 구분자(colsep)를 인자로 CSVReader를 생성한다. 컬럼 구분자는 CFG파일에서 리소스 정의시 지정할 수 있으며, 별도로 지정되지 않은 경우, StringResourceFactory의 기본값인 콤마(‘, ')가 해당 리소스의 컬럼 구분자가 된다.


 |boolean next() |. 리소스 정의에 escape="true"인 경우, VSAM파일의 한 라인을 escape 처리하여 읽어, String[] 타입의 tokens으로 생성하여 저장한다. escape가 false인 경우, escape 처리하지 않고 tokens를 생성한다.



. 별도의 escape 속성을 지정하지 않은 경우, StringResourceFactory에 의해 설정되는 escape의 디폴트값은 false이다.


 
|===============


[[runtime-architecture-resource-writer]]


===== ItemReader

:: * ItemWriter는 데이터 객체(VO)를 출력 파일이나 DB에 저장할 때 사용한다. write() 메소드를 호출하며 저장할 데이터 객체(VO)를 전달하면 데이터 객체(VO)를 변환하여 출력 파일 또는 DB에 저장한다.

* CFG 파일에 정의된 각 resource의 type에 따라 내부적으로 생성되는 Writer의 종류와 클래스간 관계는 아래 그림과 같다.



image::images/runtime-architecture-writer.png[align="center"]

[[runtime-architecture-resource-writer-sql]]


====== SQLReader

:: * SQLWriter는 리소스의 유형이 ‘DB '인 경우, DatabaseResourceFactory에 의해 생성되는 ItemWriter 이다.

* SQLWriter를 사용하여 DB 테이블에 데이터를 저장하고자 하는 경우, 아래와 같이 XML에 관련설정을 하거나, Java 프로그램 내에서 API를 사용하여 설정할 수 있다.

.작업정의(CFG)
====

----



<reader id="dbwriter1"  type="DB" url="ds-default"/>
<reader id="dbwriter2"  type="DB" url="ds-default" query-id="insert">


----


====

.java 프로그램
====

----



public void execute(ItemFactory factory) throws Exception {

ItemWriter writer01 = factory.getItemWriter("dbwriter1");

writer01.setQueryPath("sample/batch/Sample_sql.xml");
writer01.setMapping(SampleVo.class);
... ...
}


----


====

.주요 Attribute
[options="header"]
|===============
^|Attribute ^|설명 
|DataSource dataSource |쿼리 수행을 위한 DB접속정보를 가지고 있는 데이터소스.



CFG 파일에서 resource 정의 시 설정된 ‘url ' 속성에 따라 정해진다.


 |QueryManager queryManager |별도 Xml에 정의된 쿼리를 관리하는 객체로, 실제 구현체는 CachedXmlQueryManager이다.  
|boolean allowCustomQuery |리소스에서 사용하는 쿼리를 Java 프로그램 내부에서 수정가능한지 여부. 기본값은 false이다. 
|Object parameters |해당 리소스에 설정된 파라미터 값들 
|String queryPath |쿼리 파일의 위치. XML에 query-file 이 정의되어 있지 않은 경우, StepParser에 의해 Default로 java 클래스와 동일한 위치에 클래스명_sql.xml로 지정된다.



예) com.sample.MyBat =&gt; com/sample/MyBat_sql.xml


 |String query |수행해야하는 쿼리 
|boolean batchUpdate |일괄 업데이트 여부  

|===============


.주요 Method
[options="header"]
|===============
^|Method ^|설명 
|void open(ExecutionContext) |. TaskStep이 수행될 때 호출되며, CFG 파일에 정의된 값을 기준으로 아래와 같은 속성들을 셋팅한다. : batchUpdate, queryPath, query



. batchUpdate는 CFG 파일에서 정의할 수 있으나, 명시하지 않는 경우, 기본값은 false이다.


 |int write() |. DataSourceUtils.getConnection(dataSource) 으로 커넥션을 획득하고, 초기화시 정의된 query로 PreparedStatement를 생성한다. (최초 1회에 한함)



. batchUpdate가 true인 경우 preparedStatement.addBatch()를 수행하고, false인 경우 preparedStatement.executeUpdate()를 수행한다.



. ItemCount를 1 증가시킨다.



. update된 row의 수를 리턴한다.


 |int write(Object vo) |. write()와 마찬가지로 DataSourceUtils.getConnection(dataSource) 으로 커넥션을 획득하고, 초기화시 정의된 query로 PreparedStatement를 생성한다. (최초 1회에 한함)



. 입력인자로 전달된 VO 객체의 필드 값들을 PreparedStatement에 set한다. (TransformJdbc.encodeVo() 활용하며, 쿼리의 NamedParameter와 VO 필드명으로 매핑한다.)



. batchUpdate가 true인 경우 preparedStatement.addBatch()를 수행하고, false인 경우 preparedStatement.executeUpdate()를 수행한다.



. ItemCount를 1 증가시킨다.



. update된 row의 수를 리턴한다.


 |void setQuery(String query) |Java 프로그램 내에서 쿼리를 설정하고자 할 때 사용하며, 이 값은 allowCustomQuery가 true인 경우에만 사용이
						가능하고, allowCustomQuery가 false인 경우에는 UnsupportedOperationException이
						발생함 
|void setQueryId(String queryID) |Java 프로그램 내에서 쿼리ID를 지정하고자 할 때 사용하며, 내부적으로는 query file에서 해당 쿼리 ID를 조회하고,
						해당 쿼리가 없는 경우 BatchReaderException을 발생시키고, 해당 쿼리가 있는 경우 실행할 Query 정보로 저장한다.
					 

|===============


[[runtime-architecture-resource-writer-byte]]


====== ByteWriter

:: * ByteWriter는 리소스의 유형이 ‘SAM '인 경우, ByteResourceFactory에 의해 생성되는 ItemWriter 이다.

* ByteWriter를 사용하여 SAM 파일에 데이터를 write하고자 하는 경우, 아래와 같이 XML에 관련설정을 하거나, Java 프로그램 내에서 API를 사용하여 설정할 수 있다.

.작업정의(CFG)
====

----



<writer id="samWriter01" type="SAM" url="${BASE}/sample_${TODAY}_01_day" encoding="euc-kr"/>
<writer id="samWriter02" type="SAM" url="${BASE}/sample_${TODAY}_02_day" trim="false” append="true”/>


----


====

.주요 Method
[options="header"]
|===============
^|Method ^|설명 
|void open(ExecutionContext) |. TaskStep이 수행될 때 호출되며, CFG 파일에 정의된 값을 기준으로 아래와 같은 속성들을 셋팅한다. : columns, linesepBytes, file,



. 정의된 파일이 기존에 존재하는 경우, 기존의 파일을 삭제한다.



(append 값이 true인 경우 제외)



. 정의된 파일명에 임시 파일 suffix("._BATCH_TMP_")를 붙여 신규로 파일을 생성한다.



. 생성된 파일을 기반으로 FileOutputStream, FileChannel, BufferedOutputStream 객체를 초기화한다.


 |int write() |. lineBuffer에 저장된 내용을 파일에 write하고, ItemCount를 1 증가시킨다.  
|int write(Object vo) |. 입력인자로 전달된 VO 객체의 필드 값을 byte[]로 변환하여 파일에 write한다.



. 필드값 변환 시, TransformByteProxyAware.encodeVo()가 수행된다.


 |void changeUrl(String url) |. 현재 사용하고 있는 모든 자원을 초기화하고, URL을 변경한다.



. 배치 작업 중 writer 대상 파일의 이름을 동적으로 변경하고자 할 때 사용한다.


 
|===============


[[runtime-architecture-resource-writer-string]]


====== StringWriter

:: * StringWriter는 리소스의 유형이 ‘VSAM '인 경우, StringResourceFactory에 의해 생성되는 ItemWriter 이다.

* StringWriter를 사용하여 VSAM 파일에 데이터를 write하고자 하는 경우, 아래와 같이 XML에 관련설정을 하거나, Java 프로그램 내에서 API를 사용하여 설정할 수 있다.

.작업정의(CFG)
====

----



<writer id="wrtier" type="VSAM" url="${base}/output.txt" encoding="EUC-KR" colsep="|" show-log="true" escape="true" />


----


====

.주요 Method
[options="header"]
|===============
^|Method ^|설명 
|void open(ExecutionContext) |. TaskStep이 수행될 때 호출되며, CFG 파일에 정의된 값을 기준으로 아래와 같은 속성들을 셋팅한다. : columns, linesepBytes, file,



. 정의된 charset에 해당하는 encoder를 생성한다. 별도로 encoding 속성이 정의되지 않은 경우, 디폴트 값은 AbstractFileResourceFactory에 의해 "UTF-8"로 설정된다.



. encoding 시 매핑되지 않는 캐릭터는 공백문자(‘ ‘)로 대체한다. 해당 encoder의 공백문자로 적합하지 않은 경우, 기본 대체문자(‘? ')로 대체된다.



. 정의된 파일이 기존에 존재하는 경우, 기존의 파일을 삭제한다.



(append 값이 true인 경우 제외)



. 정의된 파일명에 임시 파일 suffix("._BATCH_TMP_")를 붙여 신규로 파일을 생성한다.



. 생성된 파일을 기반으로 FileOutputStream, FileChannel, BufferedOutputStream 객체를 초기화한다.


 |int write() |. 본 메소드를 사용하기 이전에 setter 메소드를 사용하여 columns 속성이 반드시 설정되어야 한다.



. StringResourceFactory에 의해 생성된 LineAggregator 객체의 종류에 따라 File에 write할 한 라인의 데이터가 구성된다.



. EscapeDelimitLineAggregator : escape 속성이 정의된 경우



. DelimitedLineAggregator : escape 속성이 정의되지 않은 경우



. LineAggregator에 의해 구성된 문자열을 파일에 write한다.



. ItemCount를 1 증가시킨다.


 |int write(Object vo) |. 입력인자로 전달된 VO 객체의 필드 값을 byte[]로 변환하여 파일에 write한다.



. 필드값 변환 시, TransformStringProxyAware.encodeVo()가 수행된다.



. LineAggregator에 의해 구성된 문자열을 파일에 write한다.



. ItemCount를 1 증가시킨다.


 |void changeUrl(String url) |. 현재 사용하고 있는 모든 자원을 초기화하고, URL을 변경한다.



. 배치 작업 중 writer 대상 파일의 이름을 동적으로 변경하고자 할 때 사용한다.


 
|===============


[[runtime-architecture-resource-writer-method]]


====== MethodInvokingWriter

:: * MethodInvokingWriter는 리소스의 유형이 ‘DAO '인 경우, MethodResourceFactory에 의해 생성되는 ItemWriter 이다.

* MethodInvokingWriter는 특정 DAO 클래스의 메소드를 사용하여 DB 데이터를 write하는 ItemWriter이다.

* MethodInvokingWriter를 사용하여 DB 데이터를 write하고자 하는 경우, 아래와 같이 XML에 관련설정을 하거나, Java 프로그램 내에서 API를 사용하여 설정할 수 있다.
** url에는 invoke해야 하는 DAO 클래스와 메소드가 명시된다.

.작업정의(CFG)
====

----



<writer id=“writer" type=“DAO" url=“sample.batch.dao.SampleDao.insert()" />


----


====

.주요 Method
[options="header"]
|===============
^|Method ^|설명 
|void open(ExecutionContext) |. TaskStep이 수행될 때 호출되며, CFG 파일에 정의된 값을 기준으로 invoke해야 하는 클래스의 오브젝트를 생성한다.



. CFG에 factory-method가 정의된 경우 해당 factoryMethod를 invoke하여 DAO 객체를 생성하고, factory-method가 정의되지 않은 경우 new 연산자를 사용하여 DAO 객체를 생성한다.



. 재시작인 경우, 리소스 컨텍스트를 restore한다.


 |int write(Object vo) |. ItemCount를 1 증가시킨다.



. DAO method를 invoke시킨다.



. DAO method 수행 결과를 리턴한다.


 
|===============




[NOTE]
====

		DAO type 의 경우 Anyframe Batch 기본 설정파일 외에 해당 사이트에 맞는 DAO 실행을 
		위한 추가 설정이 필요하다. 


	
====



====== JOB APPLICATION ( 작업 목록 ) 실행

경우에 따라서 여러 Job 을 순차적으로 실행할 필요가 있을 경우 JOB APPLICATION 실행 기능을 사용할 수 있다. 

[NOTE]
====

- 예 ) runjob.sh sample/batch/hello/cfg/hello_cfg.xml -JOBAPPLICATION=sample/batch/hello/cfg/hello2_cfg.xml;sample/batch/hello/cfg/hello3_cfg.xml

- hello_cfg -> hello2_cfg -> hello3_cfg 순으로 실행됨 

- 각 Job 이 COMPLETED 상태로 종료 되어야 후속 Job 이 수행됨

====

JOB APPLICATION 기능 사용을 위해서는 아래의 설정이 필요하다. 

( 작업이 COMPLETED 로 종료가 되면 Batch Agent 에 다음 작업 요청을 하는 방식 )

- agentURL - 후속 작업실행을 요청할 Batch Agent IP:port

.context-batch-runtime.xml ( Job Application 실행 Listener 등록 )
====

----

<bean id="jobApplicationListener" class="com.anyframe.batch.core.job.support.JobApplicationListener">
	<property name="agentUrl" value="127.0.0.1:15000/batch-agent"/>
</bean>

----

====